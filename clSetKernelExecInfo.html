<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>clSetKernelExecInfo</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body id="clSetKernelExecInfo" class="article">
<div id="header">
<h1>clSetKernelExecInfo</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Pass additional information other than argument values to a kernel.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">cl_int clSetKernelExecInfo(cl_kernel kernel,
                           cl_kernel_exec_info param_name,
                           size_t param_value_size,
                           const void *param_value)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="parameters">Parameters</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1"><code>kernel</code></dt>
<dd>
<p>Specifies the kernel object being queried.</p>
</dd>
<dt class="hdlist1"><code>param_name</code></dt>
<dd>
<p>Specifies the information to be passed to <code>kernel</code>.
The list of supported <code>param_name</code> types and the corresponding values passed in <code>param_value</code> is described in the table below.</p>
</dd>
<dt class="hdlist1"><code>param_value_size</code></dt>
<dd>
<p>Specifies the size in bytes of the memory pointed to by <code>param_value</code>.</p>
</dd>
<dt class="hdlist1"><code>param_value</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>A pointer to memory where the appropriate values determined by <code>param_name</code> are specified.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">cl_kernel_exec_info</th>
<th class="tableblock halign-left valign-top">Type and Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>CL_KERNEL_EXEC_INFO_SVM_PTRS</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>Type: void *[]</p>
</div>
<div class="paragraph">
<p>SVM pointers used by a kernel which are not passed as arguments to <code>kernel</code>.
These addresses may be defined in SVM buffer(s) that are passed as arguments to <code>kernel</code>.</p>
</div>
<div class="paragraph">
<p>These non-argument SVM pointers must be specified using <code>clSetKernelExecInfo</code> for coarse-grain and fine-grain buffer SVM allocations but not for fine-grain system SVM allocations.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p><code>CL_KERNEL_EXEC_INFO_SVM_- FINE_GRAIN_SYSTEM</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div><div class="paragraph">
<p>Type: cl_bool</p>
</div>
<div class="paragraph">
<p>This flag indicates whether the kernel uses pointers that are fine grain system SVM allocations.
These fine grain system SVM pointers may be passed as arguments or defined in SVM buffers that are passed as argumentsto <code>kernel</code>.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="notes">Notes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>1.
Coarse-grain or fine-grain buffer SVM pointers used by a kernel which are not passed as a kernel arguments must be specified using <code>clSetKernelExecInfo</code> with <code>CL_KERNEL_EXEC_INFO_SVM_PTRS</code>.
For example, if SVM buffer A contains a pointer to another SVM buffer B, and the kernel dereferences that pointer, then a pointer to B must either be passed as an argument in the call to that kernel or it must be made available to the kernel using <code>clSetKernelExecInfo</code>.
For example, we might pass extra SVM pointers as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>clSetKernelExecInfo(kernel,
     CL_KERNEL_EXEC_INFO_SVM_PTRS,
     num_ptrs * sizeof(void *),
     extra_svm_ptr_list);</pre>
</div>
</div>
<div class="paragraph">
<p>Here <code>num_ptrs</code> specifies the number of additional SVM pointers while <code>extra_svm_ptr_list</code> specifies a pointer to memory containing those SVM pointers.</p>
</div>
<div class="paragraph">
<p>When calling <code>clSetKernelExecInfo</code> with <code>CL_KERNEL_EXEC_INFO_SVM_PTRS</code> to specify pointers to non-argument SVM buffers as extra arguments to a kernel, each of these pointers can be the SVM pointer returned by <a href="clSVMAlloc.html"><code>clSVMAlloc</code></a> or can be a pointer + offset into the SVM region.
It is sufficient to provide one pointer for each SVM buffer used.</p>
</div>
<div class="paragraph">
<p>2.
<code>CL_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM</code> is used to indicate whether SVM pointers used by a kernel will refer to system allocations or not.</p>
</div>
<div class="paragraph">
<p><code>CL_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM</code> = <code>CL_FALSE</code> indicates that the OpenCL implementation may assume that system pointers are not passed as kernel arguments and are not stored inside SVM allocations passed as kernel arguments.</p>
</div>
<div class="paragraph">
<p><code>CL_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM</code> = <code>CL_TRUE</code> indicates that the OpenCL implementation must assume that system pointers might be passed as kernel arguments and/or stored inside SVM allocations passed as kernel arguments.
In this case, if the device to which the kernel is enqueued does not support system SVM pointers, <a href="clEnqueueNDRangeKernel.html"><code>clEnqueueNDRangeKernel</code></a> will return a <code>CL_INVALID_OPERATION</code> error.
If none of the devices in the context associated with kernel support fine-grain system SVM allocations, <code>clSetKernelExecInfo</code> will return a <code>CL_INVALID_OPERATION</code> error.</p>
</div>
<div class="paragraph">
<p>If <code>clSetKernelExecInfo</code> has not been called with a value for <code>CL_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM</code> the default value is used for this kernel attribute.
The defaule value depends on whether the device on which the kernel is enqueued supports fine-grain system SVM allocations.
If so, the default value used is <code>CL_TRUE</code> (system pointers might be passed); otherwise, the default is <code>CL_FALSE</code>.</p>
</div>
<div class="paragraph">
<p>3.
A call to <code>clSetKernelExecInfo</code> for a given value of <code>param_name</code> replaces any prior value passed for that value of <code>param_name</code>.
Only one <code>param_value</code> will be stored for each value of <code>param_name</code>.</p>
</div>
<div class="paragraph">
<div class="title">Multiple Host Threads</div>
<p>An OpenCL API call is considered to be <em>thread-safe</em> if the internal state as managed by OpenCL remains consistent when called simultaneously by multiple <em>host</em> threads.
OpenCL API calls that are <em>thread-safe</em> allow an application to call these functions in multiple <em>host</em> threads without having to implement mutual exclusion across these <em>host</em> threads i.e.
they are also re-entrant-safe.</p>
</div>
<div class="paragraph">
<p>All OpenCL API calls are thread-safe except those that modify the state of cl_kernel objects: <a href="clSetKernelArg.html"><code>clSetKernelArg</code></a>, <a href="clSetKernelArgSVMPointer.html"><code>clSetKernelArgSVMPointer</code></a>, <a href="#"><code>clSetKernelExecInfo</code></a> and <a href="clCloneKernel.html"><code>clCloneKernel</code></a>.</p>
</div>
<div class="paragraph">
<p><a href="clSetKernelArg.html"><code>clSetKernelArg</code></a> , <a href="clSetKernelArgSVMPointer.html"><code>clSetKernelArgSVMPointer</code></a>, <a href="#"><code>clSetKernelExecInfo</code></a> and <a href="clCloneKernel.html"><code>clCloneKernel</code></a> are safe to call from any host thread, and safe to call re-entrantly so long as concurrent calls to any combination of these API calls operate on different cl_kernel objects.
The state of the cl_kernel object is undefined if <a href="clSetKernelArg.html"><code>clSetKernelArg</code></a>, <a href="clSetKernelArgSVMPointer.html"><code>clSetKernelArgSVMPointer</code></a>, <a href="#"><code>clSetKernelExecInfo</code></a> or <a href="clCloneKernel.html"><code>clCloneKernel</code></a> are called from multiple host threads on the same cl_kernel object at the same time.
Please note that there are additional limitations as to which OpenCL APIs may be called from OpenCL callback functions&#8201;&#8212;&#8201;please see section 5.11.</p>
</div>
<div class="paragraph">
<p>The behavior of OpenCL APIs called from an interrupt or signal handler is implementation-defined.</p>
</div>
<div class="paragraph">
<p>There is an inherent race condition in the design of OpenCL that occurs between setting a kernel argument and using the kernel with <a href="clEnqueueNDRangeKernel.html"><code>clEnqueueNDRangeKernel</code></a>.
Another host thread might change the kernel arguments between when a host thread sets the kernel arguments and then enqueues the kernel, causing the wrong kernel arguments to be enqueued.
Rather than attempt to share <code>cl_kernel</code> objects among multiple host threads, applications are strongly encouraged to make additional <code>cl_kernel</code> objects for kernel functions for each host thread.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="errors">Errors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Returns <code>CL_SUCCESS</code> if the function is executed successfully.
Otherwise, it returns one of the following errors:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CL_INVALID_KERNEL</code> if <code>kernel</code> is not a valid kernel object.</p>
</li>
<li>
<p><code>CL_INVALID_VALUE</code> if <code>param_name</code> is not valid, if <code>param_value</code> is NULL or if the size specified by <code>param_value_size</code> is not valid.</p>
</li>
<li>
<p><code>CL_INVALID_OPERATION</code> if <code>param_name</code> = <code>CL_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM</code> and <code>param_value</code> = <code>CL_TRUE</code> but no devices in context associated with <code>kernel</code> support fine-grain system SVM allocations.</p>
</li>
<li>
<p><code>CL_OUT_OF_RESOURCES</code> if there is a failure to allocate resources required by the OpenCL implementation on the device.</p>
</li>
<li>
<p><code>CL_OUT_OF_HOST_MEMORY</code> if there is a failure to allocate resources required by the OpenCL implementation on the host.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="seealso">Also see</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="clCreateKernel.html"><code>clCreateKernel</code></a>, <a href="clGetKernelInfo.html"><code>clGetKernelInfo</code></a>, <a href="clGetKernelArgInfo.html"><code>clGetKernelArgInfo</code></a>, <a href="clCreateKernelsInProgram.html"><code>clCreateKernelsInProgram</code></a>, <a href="clSetKernelArg.html"><code>clSetKernelArg</code></a>, <a href="clGetKernelWorkGroupInfo.html"><code>clGetKernelWorkGroupInfo</code></a>, <a href="clEnqueueNDRangeKernel.html"><code>clEnqueueNDRangeKernel</code></a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="specification">Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://www.khronos.org/registry/cl/specs/opencl-2.1.pdf#page=227" target="_blank">OpenCL 2.1 API Specification, page 227</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="copyright">Copyright</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="copyright.html">Copyright &#169; 2007-2017 The Khronos Group Inc.</a></p>
</div>
</div>
</div>
</div>
</body>
</html>