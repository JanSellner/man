<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>Attributes of Types</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body id="AttributesofTypes" class="article">
<div id="header">
<h1>Attributes of Types</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Attributes of Types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>__attribute__ ((aligned))
__attribute__ ((aligned (n)))
__attribute__ ((packed))</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The keyword <code><em>attribute</em></code> allows you to specify special attributes of <code>enum</code>, <code>struct</code> and <code>union</code> types when you define such types.
This keyword is followed by an attribute specification inside double parentheses.
Two attributes are currently defined for types: aligned, and packed.</p>
</div>
<div class="paragraph">
<p>You may specify type attributes in an <code>enum</code>, <code>struct</code>, or <code>union</code> type declaration or definition, or for other types in a <code>typedef</code> declaration.</p>
</div>
<div class="paragraph">
<p>For an <code>enum</code>, <code>struct</code>, or <code>union</code> type, you may specify attributes either between the <code>enum</code>, <code>struct</code> or <code>union</code> tag and the name of the type, or just past the closing curly brace of the <em>definition</em>.
The former syntax is preferred.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aligned">aligned (<code>alignment</code>)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This attribute specifies a minimum alignment (in bytes) for variables of the specified type.
For example, the declarations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                            struct S { short f[3]; } __attribute__ ((aligned (8)));
    typedef int more_aligned_int __attribute__ ((aligned (8)));</pre>
</div>
</div>
<div class="paragraph">
<p>force the compiler to insure (as far as it can) that each variable whose type is <code>struct S</code> or <code>more_aligned_int</code> will be allocated and aligned <em>at least</em> on a 8-byte boundary.</p>
</div>
<div class="paragraph">
<p>Note that the alignment of any given <code>struct</code> or <code>union</code> type is required by the ISO C standard to be at least a perfect multiple of the lowest common multiple of the alignments of all of the members of the <code>struct</code> or <code>union</code> in question and must also be a power of two.
This means that you <em>can</em> effectively adjust the alignment of a <code>struct</code> or <code>union</code> type by attaching an aligned attribute to any one of the members of such a type, but the notation illustrated in the example above is a more obvious, intuitive, and readable way to request the compiler to adjust the alignment of an entire <code>struct</code> or <code>union</code> type.</p>
</div>
<div class="paragraph">
<p>As in the preceding example, you can explicitly specify the alignment (in bytes) that you wish the compiler to use for a given <code>struct</code> or <code>union</code> type.
Alternatively, you can leave out the alignment factor and just ask the compiler to align a type to the maximum useful alignment for the target machine you are compiling for.
For example, you could write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                            struct S { short f[3]; } __attribute__ ((aligned));</pre>
</div>
</div>
<div class="paragraph">
<p>Whenever you leave out the alignment factor in an <code>aligned</code> attribute specification, the compiler automatically sets the alignment for the type to the largest alignment which is ever used for any data type on the target machine you are compiling for.
In the example above, the size of each <code>short</code> is 2 bytes, and therefore the size of the entire <code>struct S</code> type is 6 bytes.
The smallest power of two which is greater than or equal to that is 8, so the compiler sets the alignment for the entire <code>struct S</code> type to 8 bytes.</p>
</div>
<div class="paragraph">
<p>Note that the effectiveness of aligned attributes may be limited by inherent limitations of the OpenCL device and compiler.
For some devices, the OpenCL compiler may only be able to arrange for variables to be aligned up to a certain maximum alignment.
If the OpenCL compiler is only able to align variables up to a maximum of 8 byte alignment, then specifying <code>aligned(16)</code> in an <code><em>attribute</em></code> will still only provide you with 8 byte alignment.
See your platform-specific documentation for further information.</p>
</div>
<div class="paragraph">
<p>The <code>aligned</code> attribute can only increase the alignment; but you can decrease it by specifying <code>packed</code> as well.
See below.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="packed">packed</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>packed</code> attribute, attached to the <code>struct</code> or <code>union</code> type definition, specifies that each member of the structure or union is placed to minimize the memory required.
When attached to an <code>enum</code> definition, it indicates that the smallest integral type should be used.</p>
</div>
<div class="paragraph">
<p>Specifying this attribute for <code>struct</code> and <code>union</code> types is equivalent to specifying the <code>packed</code> attribute on each of the structure or union members.</p>
</div>
<div class="paragraph">
<p>In the following example <code>struct my_packed_struct&#8217;s members are packed closely together, but the internal layout of its `s</code> member is not packed.
To do that, <code>struct my_unpacked_struct</code> would need to be packed, too.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>                            struct my_unpacked_struct
    {
        char c;
        int i;
    };

    struct __attribute__ ((packed)) my_packed_struct
    {
        char c;
        int i;
        struct my_unpacked_struct s;
    };</pre>
</div>
</div>
<div class="paragraph">
<p>You may only specify this attribute on the definition of a <code>enum</code>, <code>struct</code>, or <code>union</code>, not on a <code>typedef</code> which does not also define the enumerated type, structure or union.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="seealso">Also see</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="attribute.html"><code><em>attribute</em></code></a>, <a href="attributes-blocksAndControlFlow.html">Blocks and Control-Flow Statement Attributes</a>, <a href="attributes-variables.html">Variable Attributes</a>, <a href="attributes-loopUnroll.html">Loop Unroll Attributes</a>, <a href="qualifiers.html">Qualifiers</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="specification">Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#page=57" target="_blank">OpenCL 2.0 C Language Specification, page 57</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="copyright">Copyright</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="copyright.html">Copyright &#169; 2007-2017 The Khronos Group Inc.</a></p>
</div>
</div>
</div>
</div>
</body>
</html>