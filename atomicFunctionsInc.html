<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>Untitled</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="paragraph">
<p>In these operation definitions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An <code>A</code> refers to one of the atomic types.</p>
</li>
<li>
<p>A <code>C</code> refers to its corresponding non-atomic type.</p>
</li>
<li>
<p>An <code>M</code> refers to the type of the other argument for arithmetic operations.
For atomic integer types, <code>M</code> is <code>C</code>.</p>
</li>
<li>
<p>The functions not ending in explicit have the same semantics as the corresponding explicit function with <code>memory_order_seq_cst</code> for the <code>memory_order</code> argument.</p>
</li>
<li>
<p>The functions that do not have <code>memory_scope</code> argument have the same semantics as the corresponding functions with the <code>memory_scope</code> argument set to <code>memory_scope_device</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
With fine-grained system SVM, sharing happens at the granularity of individual loads and stores anywhere in host memory.
Memory consistency is always guaranteed at synchronization points, but to obtain finer control over consistency, the OpenCL atomics functions may be used to ensure that the updates to individual data values made by one unit of execution are visible to other execution units.
In particular, when a host thread needs fine control over the consistency of memory that is shared with one or more OpenCL devices, it must use atomic and fence operations that are compatible with the C11 atomic operations.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We can&#8217;t require C11 atomics since host programs can be implemented in other programming languages and versions of C or C++, but we do require that the host programs use atomics and that those atomics be compatible with those in C11.</p>
</div>
<div class="paragraph">
<div class="title">Restrictions</div>
<p>All operations on atomic types must be performed using the built-in atomic functions.
C11 and C++11 support operators on atomic types.
OpenCL C does not support operators with atomic types.
Using atomic types with operators should result in a compilation error.</p>
</div>
<div class="paragraph">
<p>The <code>atomic_bool</code>, <code>atomic_char</code>, <code>atomic_uchar</code>, <code>atomic_short</code>, <code>atomic_ushort</code>, <code>atomic_intmax_t</code> and <code>atomic_uintmax_t</code> types are not supported by OpenCL C.</p>
</div>
<div class="paragraph">
<p>OpenCL C requires that the built-in atomic functions on atomic types are lock-free.</p>
</div>
<div class="paragraph">
<p>The <code>_Atomic</code> type specifier and <code>_Atomic</code> type qualifier are not supported by OpenCL C.</p>
</div>
<div class="paragraph">
<p>The behavior of atomic operations where pointer arguments to the atomic functions refers to an atomic type in the private address space is undefined.</p>
</div>
</div>
</body>
</html>