<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>__global</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body id="__global" class="article">
<div id="header">
<h1>__global</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Address space qualifier.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>__global
global</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="description">Description</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>__global</code> or <code>global</code> address space name is used to refer to memory objects (buffer or image objects) allocated from the global memory pool.</p>
</div>
<div class="paragraph">
<p>A buffer memory object can be declared as a pointer to a scalar, vector or user-defined struct.
This allows the kernel to read and/or write any location in the buffer.</p>
</div>
<div class="paragraph">
<p>The actual size of the array memory object is determined when the memory object is allocated via appropriate API calls in the host code.</p>
</div>
<div class="paragraph">
<p>As image objects are always allocated from the global address space, the <code>__global</code> or <code>global</code> qualifier should not be specified for image types.
The elements of an image object cannot be directly accessed.
Built-in functions to read from and write to an image object are provided.</p>
</div>
<div class="paragraph">
<p>Variables defined at program scope and static variables inside a function can also be declared in the <code>global</code> address space.
They can be defined with any valid OpenCL C data type except for those in table 6.3.
In particular, such program scope variables may be of any user-defined type, or a pointer to a user-defined type.
In the presence of shared virtual memory, these pointers or pointer members should work as expected as long as they are shared virtual memory pointers and the referenced storage has been mapped appropriately.
These variables in the <code>global</code> address space have the same lifetime as the program, and their values persist between calls to any of the kernels in the program.
These variables are not shared across devices.
They have distinct storage.</p>
</div>
<div class="paragraph">
<p>Program scope and static variables in the <code>global</code> address space may be initialized, but only with constant expressions.</p>
</div>
<div class="paragraph">
<p>The <code>const</code> qualifier can also be used with the <code>__global</code> qualifier to specify a read-only buffer memory object.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="notes">Notes</h2>
<div class="sectionbody">
<div class="paragraph">
<div class="title">General information about address space qualifiers</div>
<p>OpenCL implements the following disjoint named address spaces: <code><em>global</code>, <code></em>local</code>, <code><em>constant</code>, and <code></em>private</code>.
The address space qualifier may be used in variable declarations to specify the region of memory that is used to allocate the object.
The C syntax for type qualifiers is extended in OpenCL to include an address space name as a valid type qualifier.
If the type of an object is qualified by an address space name, the object is allocated in the specified address name; otherwise, the object is allocated in the generic address space.</p>
</div>
<div class="paragraph">
<p>The address space names without the <em> prefix i.e.
<code>global</code>, <code>local</code>, <code>constant</code> and <code>private</code> may be substituted for the corresponding address space names with the </em> prefix.</p>
</div>
<div class="paragraph">
<p>The address space name for arguments to a function in a program, or local variables of a function is <code><em>private</code>.
All function arguments shall be in the <code></em>private</code> address space.
The address space for a variable at program scope or a static variable inside a function can either be <code><em>global</code> or <code></em>constant</code>, but defaults to <code>__global</code> if not specified.</p>
</div>
<div class="paragraph">
<p>OpenCL 2.0 adds support for an unnamed <code>generic</code> address space.
Pointers that are declared without pointing to a named address space point to the <code>generic</code> address space.
Before referring to the region pointed to, the pointer must be associated with a named address space.
Functions may be written with arguments and return values that point to the <code>generic</code> address space.</p>
</div>
<div class="paragraph">
<p>kernel function arguments declared to be a pointer or an array of a type must point to one of the named address spaces <code><em>global</code>, <code></em>local</code> or <code>__constant</code>.</p>
</div>
<div class="paragraph">
<p>The named address spaces are a subset of the generic address space except for the <code>constant</code> address space.</p>
</div>
<div class="paragraph">
<p>A pointer to address space A can only be assigned to a pointer to the same address space A or a pointer to the <code>generic</code> address space.
Casting a pointer to address space A to a pointer to address space B is illegal if A and B are named address spaces and A is not the same as B.</p>
</div>
<div class="paragraph">
<p>The <code><em>global</code>, <code></em>constant</code>, <code><em>local</code>, <code></em>private</code>, <code><em>generic</code>, <code>global</code>, <code>constant</code>, <code>local</code>, and <code>private</code> names are reserved for use as address space qualifiers and shall not be used otherwise.
The <code></em>generic</code> and <code>generic</code> names are reserved for future use.</p>
</div>
<div class="paragraph">
<p>The size of pointers to different address spaces may differ.
It is not correct to assume that, for example, <code>sizeof(<em>global int *)</code> always equals <code>sizeof(</em>local int *)</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="example1">Examples</h2>
<div class="sectionbody">
<div class="paragraph">
<p>General qualifier examples follow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>// declares a pointer p in the private address space that
// points to an object in address space global
global int *p;

void foo (...)
{
    // declares an array of 4 floats in the private address space
    float x[4];
    ...
}</pre>
</div>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>private int f() { ... } // should generate an error
local int *f() { ... } // allowed
local int * private f() { ... }; // should generate an error.</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>global float4  *color;      // An array of float4 elements
typedef struct {
      float a[3];
      int   b[2];
} foo_t;
global foo_t   *my_info;    // An array of foo_t elements.</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>global int foo;         // OK.
int foo;                // OK. Declared in the global address space
global uchar buf[512];  // OK.
global int baz = 12;    // OK. Initialization is allowed
static global int bat;  // OK. Internal linkage

global uchar bigbuf[CL_DEVICE_MAX_GLOBAL_VARIABLE_SIZE]; // OK.

static int foo;         // OK. Declared in the global address space
static global int foo;  // OK.

int *foo;               // OK. foo is allocated in global address space.
                        // pointer to foo in generic address space

void func(...)
{
   int *foo;            // OK. foo is allocated in private address space.
                        // foo points to a location in generic address space.
   ...
}

global int * global ptr;          // OK.
int * global ptr;                 // OK.
constant int *global ptr=&amp;baz;    // error since baz is in global address
                                  // space.
global int * constant ptr = &amp;baz; // OK

// Pointers work. Also, initialization to a constant known at
// program load time
global int *global baz_ptr = &amp;baz;

global image2d_t im;       // Error. Invalid type for program scope
                           // variables

global event_t ev;   // Error. Invalid type for program scope variables

global int *bad_ptr; // Error. No implicit address space</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="seealso">Also see</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="local.html"><code><em>local</code></a>, <a href="constant.html"><code></em>constant</code></a>, <a href="private.html"><code>__private</code></a>, <a href="qualifiers.html"><code>qualifiers</code></a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="specification">Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#page=34" target="_blank">OpenCL 2.0 C Language Specification, page 34</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="copyright">Copyright</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="copyright.html">Copyright &#169; 2007-2017 The Khronos Group Inc.</a></p>
</div>
</div>
</div>
</div>
</body>
</html>