<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>Example</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="paragraph">
<div class="title">General information about event functions</div>
<p>Events can be used to identify commands enqueued to a command-queue from the host.
These events created by the OpenCL runtime can only be used on the host i.e.
as events passed in <code>event_wait_list</code> argument to various clEnqueue APIs or runtime APIs that take events as arguments such as <a href="clRetainEvent.html"><code>clRetainEvent</code></a>, <a href="clReleaseEvent.html"><code>clReleaseEvent</code></a>, <a href="clGetEventProfilingInfo.html"><code>clGetEventProfilingInfo</code></a>.</p>
</div>
<div class="paragraph">
<p>Similarly, events can be used to identify commands enqueued to a device queue (from a kernel).
These event objects cannot be passed to the host or used by OpenCL runtime APIs such as the clEnqueueAPIs or runtime APIs that take event arguments.</p>
</div>
<div class="paragraph">
<p><a href="clRetainEvent.html"><code>clRetainEvent</code></a> and <a href="clReleaseEvent.html"><code>clReleaseEvent</code></a> will return <code>CL_INVALID_OPERATION</code> if <code>event</code> specified is an event that refers to any kernel enqueued to a device queue using <a href="enqueue_kernel.html"><code>enqueue_kernel</code></a> or <a href="enqueue_marker.html"><code>enqueue_marker</code></a> or is a user event created by <a href="create_user_event.html"><code>create_user_event</code></a>.</p>
</div>
<div class="paragraph">
<p>Similarly, <a href="clSetUserEventStatus.html"><code>clSetUserEventStatus</code></a> can only be used to set the execution status of events created using <a href="clCreateUserEvent.html"><code>clCreateUserEvent</code></a>.
User events created on the device can be set using <a href="set_user_event_status.html"><code>set_user_event_status</code></a> built-in function.</p>
</div>
<div class="sect1">
<h2 id="example1">Example</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The example below shows how events can be used with kernels enqueued to multiple device queues.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>extern void barA_kernel(...);
extern void barB_kernel(...);

kernel void
foo(queue_t q0, queue q1, ...)
{
    ...
    clk_event_t evt0;

    // enqueue kernel to queue q0
    enqueue_kernel(q0,
                   CLK_ENQUEUE_FLAGS_NO_WAIT,
                   ndrange_A,
                   0, NULL, &amp;evt0,
                   ^{barA_kernel(...);} );

    // enqueue kernel to queue q1
    enqueue_kernel(q1,
                   CLK_ENQUEUE_FLAGS_NO_WAIT,
                   ndrange_B,
                   1, &amp;evt0, NULL,
                   ^{barB_kernel(...);} );

    // release event evt0. This will get released
    // after barA_kernel enqueued in queue q0 has finished
    // execution and barB_kernel enqueued in queue q1 and
    // waits for evt0 is submitted for execution i.e. wait
    // for evt0 is satisfied.
    release_event(evt0);
}</pre>
</div>
</div>
<div class="paragraph">
<p>The example below shows how the marker command can be used with kernels enqueued to a device queue.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>kernel void
foo(queue_t q, ...)
{
    ...
    clk_event_t marker_event;
    clk_event_t events[2];

    enqueue_kernel(q,
                  CLK_ENQUEUE_FLAGS_NO_WAIT,
                  ndrange,
                  0, NULL, &amp;events[0],
                  ^{barA_kernel(...);} );

    enqueue_kernel(q,
                  CLK_ENQUEUE_FLAGS_NO_WAIT,
                  ndrange,
                  0, NULL, &amp;events[1],
                  ^{barB_kernel(...);} );

    // barA_kernel and barB_kernel can be executed
    // out of order. we need to wait for both these
    // kernels to finish execution before barC_kernel
    // starts execution so we enqueue a marker command and
    // then enqueue barC_kernel that waits on the event
    // associated with the marker.

    enqueue_marker(q, 2, events, &amp;marker_event);

    enqueue_kernel(q,
                   CLK_ENQUEUE_FLAGS_NO_WAIT,
                   1, &amp;marker_event, NULL,
                   ^{barC_kernel(...);} );

    release_event(events[0];
    release_event(events[1]);
    release_event(marker_event);
}</pre>
</div>
</div>
</div>
</div>
</div>
</body>
</html>